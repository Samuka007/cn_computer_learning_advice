[{"content":"","date":"3 September 2023","permalink":"/tags/c++/","section":"Tags","summary":"","title":"C++"},{"content":"","date":"3 September 2023","permalink":"/tags/program/","section":"Tags","summary":"","title":"Program"},{"content":"","date":"3 September 2023","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":" Introduct # A classic \u0026rsquo;tower of Hanoi\u0026rsquo; recursion solution, with graphic display.\nCode # Godbolt: https://godbolt.org/z/5z33oTPK4\n#include \u0026lt;thread\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // helper for printing same chars namespace help { inline void putchars( size_t n, char c ) { std::cout \u0026lt;\u0026lt; std::setfill(c) \u0026lt;\u0026lt; std::setw(n) \u0026lt;\u0026lt; \u0026#34;\u0026#34;; } } class Disk { public: Disk( size_t size ) : _size { size } {} inline size_t size() const { return _size; } private: size_t _size; // radius }; class Tower : public std::stack\u0026lt;Disk\u0026gt; // It\u0026#39;s obvious that a Tower is a stack of disk { public: Tower( size_t height ) : height ( height ) {} // height == max radius void print() { for ( size_t i = 0; i \u0026lt; height - this-\u0026gt;size() + 1; ++i ) { help::putchars(this-\u0026gt;size() + 2, \u0026#39; \u0026#39;); std::cout \u0026lt;\u0026lt; \u0026#39;|\u0026#39;; help::putchars(this-\u0026gt;size() + 2, \u0026#39; \u0026#39;); std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } for ( const auto\u0026amp; disk : this-\u0026gt;c ) { help::putchars( height - disk.size() + 1, \u0026#39; \u0026#39; ); std::cout \u0026lt;\u0026lt; \u0026#39;\u0026lt;\u0026#39;; help::putchars( disk.size() * 2 + 1, \u0026#39;=\u0026#39; ); std::cout \u0026lt;\u0026lt; \u0026#39;\u0026gt;\u0026#39;; help::putchars( height - disk.size() + 1, \u0026#39; \u0026#39; ); std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } void print_by_line ( size_t line ) // line start by 0 { size_t head = height - this-\u0026gt;size() + 1; if ( line \u0026lt; head ) { help::putchars( height + 2, \u0026#39; \u0026#39;); std::cout \u0026lt;\u0026lt; \u0026#39;|\u0026#39;; help::putchars( height + 2, \u0026#39; \u0026#39;); } else { auto\u0026amp; disk = this-\u0026gt;c.at( this-\u0026gt;size() - line + head - 1 ); // Should have a better way to locate, but what ever help::putchars( height - disk.size() + 1, \u0026#39; \u0026#39; ); std::cout \u0026lt;\u0026lt; \u0026#39;\u0026lt;\u0026#39;; help::putchars( disk.size() * 2 + 1, \u0026#39;=\u0026#39; ); std::cout \u0026lt;\u0026lt; \u0026#39;\u0026gt;\u0026#39;; help::putchars( height - disk.size() + 1, \u0026#39; \u0026#39; ); } } void operator\u0026gt;\u0026gt; ( Tower\u0026amp; rhs ) // reload for moving the top disk to rhs { rhs.push( this-\u0026gt;top() ); this-\u0026gt;pop(); } private: size_t height; }; class Hanoi3 : protected std::vector\u0026lt;Tower\u0026gt; { public: static constexpr size_t col_num = 3; Hanoi3 ( size_t disk_num = 3 ) : std::vector\u0026lt;Tower\u0026gt; ( col_num, Tower(disk_num) ), height ( disk_num ) { for ( size_t i=disk_num; i\u0026gt;0; --i ) { this-\u0026gt;at(0).push(Disk(i)); } } // recursion entry void recursion() { print(0); // print step 0 _recursion( this-\u0026gt;at(0), this-\u0026gt;at(1), this-\u0026gt;at(2), height ); } // Main recursion function void _recursion( Tower\u0026amp; src, Tower\u0026amp; des, Tower\u0026amp; mid, size_t mv_size ) { static size_t step {1}; // log step if ( mv_size == 1 ) { src \u0026gt;\u0026gt; des ; print( step++ ); return ; } _recursion( src, mid, des, mv_size-1 ); src \u0026gt;\u0026gt; des; print( step++ ); _recursion( mid, des, src, mv_size-1); } void print() { help::putchars(this-\u0026gt;size() * ( 2 * ( height + 2 ) + 1), \u0026#39;+\u0026#39;); std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; _print(); } private: size_t height; void print( size_t step ) { std::cout \u0026lt;\u0026lt; std::setfill(\u0026#39;+\u0026#39;) \u0026lt;\u0026lt; std::setw(this-\u0026gt;size() * ( 2 * ( height + 2 ) + 1)) \u0026lt;\u0026lt; std::left \u0026lt;\u0026lt; (\u0026#34;step \u0026#34; + std::to_string(step)) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; _print(); } void _print() { for ( size_t i=0 ; i\u0026lt;height+1 ; ++i ) { for ( auto\u0026amp; tow : *this ) { tow.print_by_line ( i ); } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { // call hanoi recurison solusion and print the animation. Hanoi3(3).recursion(); } Result # Program returned: 0 Program stdout step 0+++++++++++++++++++++++++++ | | | \u0026lt;===\u0026gt; | | \u0026lt;=====\u0026gt; | | \u0026lt;=======\u0026gt; | | step 1+++++++++++++++++++++++++++ | | | | | | \u0026lt;=====\u0026gt; | | \u0026lt;=======\u0026gt; \u0026lt;===\u0026gt; | step 2+++++++++++++++++++++++++++ | | | | | | | | | \u0026lt;=======\u0026gt; \u0026lt;===\u0026gt; \u0026lt;=====\u0026gt; step 3+++++++++++++++++++++++++++ | | | | | | | | \u0026lt;===\u0026gt; \u0026lt;=======\u0026gt; | \u0026lt;=====\u0026gt; step 4+++++++++++++++++++++++++++ | | | | | | | | \u0026lt;===\u0026gt; | \u0026lt;=======\u0026gt; \u0026lt;=====\u0026gt; step 5+++++++++++++++++++++++++++ | | | | | | | | | \u0026lt;===\u0026gt; \u0026lt;=======\u0026gt; \u0026lt;=====\u0026gt; step 6+++++++++++++++++++++++++++ | | | | | | | \u0026lt;=====\u0026gt; | \u0026lt;===\u0026gt; \u0026lt;=======\u0026gt; | step 7+++++++++++++++++++++++++++ | | | | \u0026lt;===\u0026gt; | | \u0026lt;=====\u0026gt; | | \u0026lt;=======\u0026gt; | ","date":"3 September 2023","permalink":"/posts/hanoi3/","section":"博客","summary":"Classic tower of Hanoi recursion solution, with graphic display.","title":"Tower of Hanoi I"},{"content":"","date":"28 August 2023","permalink":"/categories/advance/","section":"分类","summary":"","title":"Advance"},{"content":"","date":"28 August 2023","permalink":"/tags/modern-c++/","section":"Tags","summary":"","title":"Modern C++"},{"content":" 引入 # C++作为一门兼顾优雅与效率的语言，自然不会让你幸苦写几遍代码只为了辨析复制和移动～\n所以，当你再遇到像\nvoid insert ( const T\u0026amp; value ); void insert ( T\u0026amp;\u0026amp; value ); 这样要重载两次的版本时，倘若他们之间除了形参不同，没有其他不同的话，你大可以使用 完美转发 来帮你优雅地省下复制粘贴的时间～（不是\n前置知识 # 要想使用 完美转发，你需要了解：\n万能引用 与 引用折叠，见 引用声明 std::forward 并掌握一点点 模版形参推导 的知识 如果你对于上述名词感到非常陌生，对于移动构造、移动语义也不太了解，可以先了解基础知识：\n右值，见 值类别 移动构造函数 与 移动运算符 std::move Demo # 其实在cppreference中，已经讲述了 完美转发 的原理了（见 引用声明 - 转发引用）。 这里通过一个demo来演示完美转发的基本使用，你也可以点此前往 Compiler Explorer 试一试。\nTalk is cheap. Show me the code. Linus Torvalds\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;utility\u0026gt; using namespace std; struct X { X() { puts(\u0026#34;X()\u0026#34;); } virtual ~X() { puts(\u0026#34;~X()\u0026#34;); } // copy constructor // X\u0026amp;, const X\u0026amp; and const X\u0026amp;\u0026amp; will call this X( const X\u0026amp; ) { puts(\u0026#34;X( const X\u0026amp; )\u0026#34;); } // move constructor // X\u0026amp;\u0026amp; will call this X( X\u0026amp;\u0026amp; )noexcept{ puts(\u0026#34;X( X\u0026amp;\u0026amp; )\u0026#34;); } }; // here Ty can be (const) X and X\u0026amp; // if Ty == X, Ty\u0026amp;\u0026amp; == X\u0026amp;\u0026amp; // if Ty == X\u0026amp;, Ty\u0026amp;\u0026amp; == X\u0026amp; \u0026amp;\u0026amp; == X\u0026amp; template \u0026lt; typename Ty \u0026gt; void construct ( Ty\u0026amp;\u0026amp; x ) { // in order to call constructor instead of generate a reference, // here use \u0026#39;decay_t\u0026lt;Ty\u0026gt;\u0026#39; instead of \u0026#39;auto\u0026#39; // you actually can write it like // decay_t\u0026lt;decltype(x)\u0026gt; newX ( forward\u0026lt;Ty\u0026gt;(x) ); // which is a much more complex way to do the same thing decay_t\u0026lt;Ty\u0026gt; newX ( forward\u0026lt;Ty\u0026gt;(x) ); } int main() { X x; puts(\u0026#34;------\u0026#34;); construct ( x ); // newX is a copy of x puts(\u0026#34;------\u0026#34;); construct ( move(x) ); // newX is move from x puts(\u0026#34;------\u0026#34;); // x call ~X() } 或者，在C++20中，你也可以综合auto的形参推导和decltype来进一步省略：\nvoid construct ( auto\u0026amp;\u0026amp; x ) { auto newX ( forward\u0026lt;decltype(x)\u0026gt;(x) ); } 运行结果：\nx86-64 gcc 13.2 -std=c++20 Program returned: 0 Program stdout X() ------ X( const X\u0026amp; ) ~X() ------ X( X\u0026amp;\u0026amp; ) ~X() ------ ~X() 显然，construct()在传入x时，调用复制构造（形参类型为X\u0026amp;）；在传入move(x)时，调用移动构造（形参类型为X\u0026amp;\u0026amp;），理想地实现了完美转发。\n什么时候可以 auto auto ( auto auto ) { auto; }\n参考 # 在这里你也可以找到关于万能引用、引用折叠与完美转发的关系： 现代C++之万能引用、完美转发、引用折叠 - Francis - 知乎\n","date":"28 August 2023","permalink":"/articles/a-perfect-forward/","section":"文章","summary":"不想再只为某个重载了复制和移动两个版本的函数，而去写两遍一模一样的代码？你需要完美转发xd","title":"引用折叠+万能引用+std::forward == 完美转发"},{"content":" 引入 # Concept 作为 C++ 20 引入的一个新特性，是一个语法糖，同时也提供了相当一部分模版类型限定的预设，以及提供了用户友好的模版匹配失败报错。\n直接使用 概念 # 譬如，通过以下代码，你可以限定你的模版类 / 模版函数的模版类型 Ty 必须支持比较：\ntemplate \u0026lt; typename Ty \u0026gt; requires std::totally_ordered \u0026lt; Ty \u0026gt; // 要求 Ty 完全可比较 void print_less ( Ty a, Ty b ) { std::cout \u0026lt;\u0026lt; (a \u0026lt; b ? a : b) \u0026lt;\u0026lt; \u0026#34;is the less.\u0026#34;; } 当然，要使用模版库，你需要引入头文件 \u0026lt;concepts\u0026gt; ，从而使用基础库概念们的定义。\n定义 概念 # 当遇到需要复用的一系列概念的集合的限定，你可以像这样指定：\ntemplate \u0026lt; typename Ty \u0026gt; concept comparable_integral = integral\u0026lt; Ty \u0026gt; \u0026amp;\u0026amp; std::totally_ordered \u0026lt; Ty \u0026gt;; template \u0026lt; comparable_integral T \u0026gt; void check_if_int_comparable( T a, T b ) { std::cout \u0026lt;\u0026lt; (a \u0026lt; b ? a : b) ; } int main() { check_if_int_comparable( 3, 4 ); // check_if_int_comparable( 0.5, 0.6 ); // parse failed } 参考 # 更多关于 约束传入模版类型 详见 C++模板如何要求传入的类型符合要求 - mq白\n更多关于 Concept 请详见 概念库 (C++20) - cppreference.com 与 C++20高级编程(英文版) - Professional C++ ( Marc Gregoire ) 中的模版章节。\n","date":"26 August 2023","permalink":"/articles/a-elegant-type/","section":"文章","summary":"Concept 作为 \u003ccode\u003eC++ 20\u003c/code\u003e 引入的一个新特性，是一个语法糖，同时也提供了相当一部分模版类型限定的预设，以及提供了用户友好的模版匹配失败报错。","title":"如何优雅的在C++中限定模版类型"},{"content":"不得不说雷军还是你雷军。\n","date":"17 August 2023","permalink":"/posts/mi2023/","section":"博客","summary":"","title":"雷军2023年度演讲"},{"content":" Computer Science # 推荐的书 # C++20高级编程 - Professional C++ ( Marc Gregoire ) 深入理解计算机系统 - Computer Systems：A Programmer’s Perspective, 3rd Edition - EPUB 英文版 PDF 中文版 PDF 计算机网络：自顶而下方法原书 - Computer Networking A Top-Down Approach, 7th Edition 专业课 # C++大学教程（第九版） 电路与电子技术 数据结构与算法分析-C++语言描述 (英文版第4版) 数据结构与算法分析-C++语言描述 (中文版第4版) Java语言程序设计（基础篇 英文版 原书第11版 PDF）(NOT RECOMMANDED) Java语言程序设计（基础篇 英文版 原书第11版 EPUB） Java语言程序设计-中文版梁勇 计算机组成与嵌入式系统-原书第6版-中文版 Computer Organization and Embedded Systems - 6th Edition 公共课 # 数学分析 - James Stewart Calculus 7th edition 工科数学分析 华中科大(第二版) 离散数学 - discrete-mathematics-and-its-applications-eighth-edition 写作业用这本 离散数学及其应用-原书第七版中文版 概率论与数理统计 - JayL.Devore-Probability 8 ed 概率论与数理统计答案 - JayL.Devore-Probability 8 ed sol 概率论与数理统计 - PROBABILITY-AND-STATISTICS-5ed PROBABILITY-AND-STATISTICS-5ed-sol 大学物理 - Fundamentals of Physics Extended 9th 大学物理所有公式 线性代数 - Linear-Algebra-and-Its-Applications 5th 计算机经典书籍 # C/C++ # C++大学教程（第九版） 数据结构与算法分析：C语言描述_原书第2版 C++20高级编程(英文版) - Professional C++ ( Marc Gregoire ) OS \u0026amp; Network # Linux内核设计与实现(第三版中文版) 汇编语言(第3版) 王爽著 Computer Organization and Embedded Systems - 6th Edition Computer Systems：A Programmer’s Perspective, 3rd Edition - EPUB Computer Systems：A Programmer’s Perspective, 3rd Edition - PDF 深入理解计算机系统（CSAPP） 计算机网络：自顶而下方法原书 - Computer Networking A Top-Down Approach, 7th Edition Computer Networking A Top-Down Approach, 6th Edition UNIX网络编程（尚无资源） Java # Java语言程序设计（基础篇 英文版 原书第11版 PDF） Java语言程序设计（基础篇 英文版 原书第11版 EPUB） 深入理解Java虚拟机：JVM高级特性与最佳实践（第二版） Effective Java 中文第二版 数据结构与算法经典问题解析 Java语言描述 Java语言程序设计-中文版梁勇 Database and Storage # 高性能MySQL 第三版 All CS Books # 提取码 147369\nOthers # Some Skills # 压缩的艺术 提问的智慧pdf版 Chemistry # Arrow Pushing in Organic Chemistry 演習で学ぶ 有機反応機構 上诉链接若失效可在此前往下载 # 点此下载 提取码: 147369\n有效期至: 2024/08/22 10:46:28 GMT+08:00\n","date":"7 August 2023","permalink":"/articles/ebooks/","section":"文章","summary":"","title":"电子书"},{"content":" C++ # 友链 C++ 全栈知识体系 https://stibel.icu/ ","date":"5 August 2023","permalink":"/articles/n-learning-route/","section":"文章","summary":"","title":"学习路径"},{"content":" 不定时更新 # Tools # UsbEAm Hosts Editor [多平台hosts修改] V3.63 Cracked # Adobe 2022 全家桶 SP版和大师版 @vposy破解打包 - 字节智造 System # Windsys Project (Windsys.win) | 也许是最适合年轻人使用的第三方社区系统~ Office KMS KEY (GVLKs) ","date":"5 August 2023","permalink":"/articles/s-software/","section":"文章","summary":"","title":"软件集"},{"content":"下面是一些计算机人的基本素养，也是这里的基本思想（你可以认为这是乌托邦式的思想，如果你身负重任，下面的建议未必全部适用于你，因为你可能需要牺牲自己，但根本上我认为与我们的发展宗旨并不冲突，也认为这符合天下每一个父母对他们的孩子、社会上任意一位同志对同伴的期望）\n学会提问 # 尽管大部分时候友善的人们乐意为大家答疑解惑，但是适当的提问（适当的社交礼仪）更有利于我们培养思考问题的能力、提高解决问题的效率。粗略阅读该项目，以领悟 提问的智慧 点击以前往该项目，该项目提供者不提供相关服务支持 ；抑或参考其内容，让 聪明的提问 成为你成功路上的有利手段。\n学会自学 # 我敬爱的数分老师说得好：\n大学大学，大不了自己学\n进入大学，最重要的就是学会自学。进入大学，你将接触最近20年里产生的知识；也就是说，老师也不再可能如同中学阶段般把知识揉碎了讲给你听，很多时候只能起到入门的作用，甚至教给你的知识也可能不足正确，尤其是计算机的相关学科。这时，自学 便显得尤为重要。优秀的自学能力归根结底 让你能从真正符合自身发展需要的角度去考量一个知识的掌握。这让你在 有限的学习时间 与近乎爆炸般发展的 无限的学科内涵 之中取得平衡起到至关重要的作用。\n学会劳逸结合 # 实际上，这一点应结合在下一点中讲，但是又时时被误解与忽视。在这里，\n劳 = 任何 提高生产力 的行为\n逸 = 任何 改变 劳 的可能性 的行为 = 任何 改变 提高生产力 的可能性 的行为\n生产力 = 我们利用自然（环境）、改造自然（环境）的能力 ≈ 充分发展自我、实现自我的能力\n充分结合自身实际素质的努力往往能让你取得最大的效率。尽量少的将有限的时间耗费在磨洋工上，同时偶尔也可以将对学科的兴趣转化到生活中的放松上。毕竟磨洋工显然不会提高我们的生产力，同时也不是所有的学科兴趣的发展都能直接提高我们的生产力，将其放在生活中放松也是不错的选择。\n同样的，适当打打喜欢的游戏、出去吃喝玩乐等等都有助于我们回复 精力 / 理智 / 体力 / 灵感 等属性中的任一属性。平衡好实际 劳 与 逸 的比例，才能最大化我们的生产力。\n在运动这个话题上，这里是这样看的：适当的锻炼既可以视作放松，也可以视作劳动，但归根结底应该视为广义上的 劳动 (labour)， 因为它客观提高了你的身体素质，提高了你未来的生产力。因此，这里认为将 运动 视作 劳 并辅以 逸 是合理的。\n学会学真才实学 # 学真才实学，是实事求是，以发展自身生产力为宗旨。那么，任何时候我们将会意识到有时候我们的学习着实是在做无用功、有时我们确实打游戏又打的有点太多。这是正常的，很难有一个人能够将其全部的精力最大化到其生产力发展中。但只要我们并不是以自我摧毁为目标，我认为任何一名对自己有着期望的20岁左右的青年都不会行动的如同要完全摧毁自己的生产力 除非其精神\u0026quot;先进\u0026quot;到已经走到人类的背面去了 。（哪怕你天天打游戏我相信你也有着让自己实力逐步上升的期盼。）\n因此，我们有所学，有所不学；有所玩，有所不玩。问心无愧就好。\n下一章节\u0026mdash;\u0026gt;硬件推荐\n","date":"4 August 2023","permalink":"/articles/n-must-learn/","section":"文章","summary":"","title":"基本素养"},{"content":"对于Github与Microsoft平台访问有困难的，参考 软件集 下修改host文件的工具.\n电子书 # [点击前往 **Ebooks**](/articles/ebooks) 推荐资源 # C++ # Compiler Explorer - godbolt.org - 在线代码分享神器 \u0026amp; C++ Playground\nC++ 全栈知识体系 - https://stibel.icu/\nmq白 - 现代C++爱好者\nC++20 STL Cookbook 2023 - mq-b - github C++交流 QQ群：764722563 C++ 手册 cppreference.com\n现代 C++ 教程 高速上手 C++ 11/14/17/20 ( 欧长坤 第二版 )\nGoLang # The Go Playground\n开始使用 Go - Training | Microsoft Learn\nRust # Rust Playground\nRust 程序设计语言\n中文版 https://www.rustwiki.org.cn/zh-CN/book/\n英文原版 https://doc.rust-lang.org/stable/book/\n深度学习 # 《动手学深度学习》教程 动手学深度学习 Pytorch版 视频 - 跟李沐学AI 深度学习数学原理 视频 - 3Blue1Brown ( bilibili熟肉 ver ) 大学生~~ # Student-resources 学生优惠指南 Github学生开发包都有什么？ - 知乎 不知道该叫什么好 云服务商和域名篇 开发和设计工具篇1 开发和设计工具篇2 在线学习篇 欢迎支持 # 龙芯中国 ","date":"3 August 2023","permalink":"/articles/s-learning/","section":"文章","summary":"","title":"学习资料"},{"content":" 如何为项目做贡献 # 拉取请求 # 参考 拉取请求-GitHub\n添加学习资料 # 单个学习资料的上传 # 发送资源邮件至 samuka007@qq.com ，附上文件备注。\n参与管理学习资料 # 发送请求邮件至 samuka007@qq.com ，授权文件管理。\n","date":"1 August 2023","permalink":"/articles/how-to-contribute/","section":"文章","summary":"","title":"如何为项目做贡献"},{"content":"此篇文章具有时效性,若有更多疑问，请参考 学会提问 来咨询。\n如何跟上硬件发展节奏？ # Bilibili 各大科技区up is all you need. ep.\nLinus Tech Tips Youtube https://www.youtube.com/@LinusTechTips Bilibili 中文熟肉ver https://space.bilibili.com/12434430/ Forums https://linustechtips.com/ 老弟一号 Bilibili主页 https://space.bilibili.com/178429408/ 分体水VS一体水 测试文档 by 老弟一号 封神之战 - 爱发电 蒸気火鸡 行业冥灯 Bilibili主页 https://space.bilibili.com/39180492/ 笔吧评测室 Bilibili主页 https://space.bilibili.com/367877 Woodenears吾等益耳 音频数据测试网站 https://www.woodenears.com Bilibili主页 https://space.bilibili.com/1841312960 五花八门的硬件 # 学习计算机，你需要的是一台台式机？笔记本？抑或是一块树莓派？还是平板？现代设备如此多，我们该如何选择？下面是我对计算机学子需求的分析，以及一些相应的解决方案。\n需求？ # 一般而言，对于电脑设备，大学生无非以下几个需求：\n属性 - 无法衡量 + 弱 ++ 中 +++ 强 便携性 完全带不走 装进行李箱 装进书包 手提、小包 编译性能 特殊平台 相对弱 相对中 相对强 图形性能 特殊平台 也不是不能用 甜品级 打游戏、跑AI 续航 无 0-3h 4-6h 6h+ 拓展性 基本没有 仅usb与耳机口 带网口、hdmi 提供其他硬件拓展 实用性 仅特殊人群 配置较复杂 使用可能有困难 比较好用/多人用 剩下的，便是从这几点中权衡。一般来说，很多问题，加钱都可以解决。\n典型方案 # 下面用表格形式来表现从上角度考虑的，各价位的典型解决方案，不代表最佳解决方案。外设不再做推荐。\n带星号 * 的指二手或淘宝特价\n2000-3000元 # 这个价位的笔记本就没有轻薄还是游戏之分了，建议购入二手。\n平板: 小米平板6\n平板用来上课看课本写作业挺好用，而且也不是不能拿来做生产力，只是配置环境比较麻烦，而且键盘得加钱。\n笔记本*: 小新air14 2021 R5/i5, 可能捡到带独立显卡MX250/MX450的版本\n台式:\n臭打游戏的: 不算外设2080元，从 老弟一号 那提货（\n硬件 CPU* R5 3500X 主板* ASUS a320m-k RAM 2666 d4 16g GPU* gtx1660 6g 电源 400w工包 硬盘 TI-Plus5000 512G 散热 玄冰400 显示器* 任意144hz 不带显卡的台式机（指编译：\n看了一圈自己组的不如一个nuc，还小只：\nMINISFORUM UM580D 16G+500G R7-5800H 1978元 MINISFORUM UM560XT 16G+500G R5-5600H 1727元 显示器 200元左右 下面是各个解决方案的系数\n硬件 便携 编译 图形 续航 拓展 实用 小米平板6 +++ + - +++ - + 小新air14 ++ ++ + ++ + +++ 游戏台式 - +++ +++ - ++ ++ NUC + +++ ++ - +++ ++ 3000-10000元 # 笔记本: 自行了解 参考 【建议收藏】学生党必看！7月份超高性价比的笔记本电脑购买推荐！（保姆级） 台式配置: 自行了解 参考 【23年7月下旬电脑配置推荐】2000~4W 16套高性价比装机配置清单 每套都有详细解析，教你用最低预算组装一台高性价比主机！ 基本上同等价位的各个解决方案的各系数都符合下表格:\n硬件 便携 编译 图形 续航 拓展 实用 轻薄本 +++ + + +++ + + 游戏本 ++ + ++ ++ ++ +++ 游戏台式 - ++ +++ - +++ +++ 日常台式 - +++ + - +++ ++ ","date":"24 July 2023","permalink":"/articles/s-hardware/","section":"文章","summary":"","title":"硬件"},{"content":" # Previous Nextsads 这里是 SCUT 电脑诊所，这里是你的爱机的社区诊所，家庭医生，我们为一切有需要的同学提供第一站电脑诊断维修服务，只为关心你的爱机，更为你省去不必要的技术烦恼。只要是常见的电脑问题，我们都尽力为您答疑解难。\n# 志愿机制 # Previous Nextsads TODO: 完善文案\n技术支持 # Previous Nextsads 诊所精选 电子涩图\nTODO: 补充文案\n知识交流 # Previous Nextsads TODO: 补充文案\n# TODO: 公众号图片\n","date":"1 January 0001","permalink":"/official/zhaoxin2023/","section":"Official","summary":"","title":""},{"content":"这是一个为了计算机新手能更好接纳计算机知识而设的个人网站/博客，并欢迎共同编辑以及Fork。\nSamuka007/cn_computer_learning_advice 一个乱七八糟的引导与学习资料仓库 HTML 4 0 如何为项目做贡献 1 August 2023\u0026middot;更新于：8 August 2023\u0026middot;85 字\u0026middot;1 分钟 指南 ","date":"1 January 0001","permalink":"/about/","section":"Welcome to C+C!","summary":"","title":"About Us"},{"content":"","date":"1 January 0001","permalink":"/official/","section":"Official","summary":"","title":"Official"},{"content":"QQ: 947309196\nDo it well.\n","date":"1 January 0001","permalink":"/authors/samuka007/","section":"作者","summary":"QQ: 947309196","title":"Samuka007"},{"content":"","date":"1 January 0001","permalink":"/authors/cc/","section":"作者","summary":"","title":"SCUT Computer Clinic"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"We have nothing to say here.\nAs for the project, click here.\n","date":"1 January 0001","permalink":"/","section":"Welcome to C+C!","summary":"We have nothing to say here.","title":"Welcome to C+C!"},{"content":"","date":"1 January 0001","permalink":"/posts/","section":"博客","summary":"","title":"博客"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"分类","summary":"","title":"分类"},{"content":"这里是 有用的文章 的集合。\n","date":"1 January 0001","permalink":"/articles/","section":"文章","summary":"","title":"文章"},{"content":"","date":"1 January 0001","permalink":"/categories/guide/","section":"分类","summary":"","title":"指南"},{"content":"","date":"1 January 0001","permalink":"/categories/resource/","section":"分类","summary":"","title":"资源"},{"content":"这里是我们部门的热心作者呀XD\n","date":"1 January 0001","permalink":"/authors/","section":"作者","summary":"","title":"作者"}]